---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: rescue-sa
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: rescue-cluster-reader
rules:
- apiGroups: [""]
  resources:
    - nodes
    - namespaces
    - pods
    - services
    - endpoints
    - configmaps
    - secrets
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources:
    - deployments
    - daemonsets
    - replicasets
  verbs: ["get", "list", "watch"]
- apiGroups: ["networking.k8s.io"]
  resources:
    - ingresses
  verbs: ["get", "list", "watch"]
- apiGroups: ["rbac.authorization.k8s.io"]
  resources:
    - roles
    - rolebindings
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: rescue-sa-binding
subjects:
- kind: ServiceAccount
  name: rescue-sa
  namespace: default
roleRef:
  kind: ClusterRole
  name: rescue-cluster-reader
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: Secret
metadata:
  name: rescue-sa-token
  annotations:
    kubernetes.io/service-account.name: rescue-sa
type: kubernetes.io/service-account-token
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rescue-web
  labels:
    app: rescue-web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rescue-web
  template:
    metadata:
      labels:
        app: rescue-web
    spec:
      serviceAccountName: rescue-sa
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html
        # We'll dynamically generate index.html by reading the token from filesystem
        command: ["/bin/sh", "-c"]
        args:
          - |
            # Wait until token is available in the default SA path
            while [ ! -f /var/run/secrets/kubernetes.io/serviceaccount/token ]; do
              echo "Waiting for service account token..."
              sleep 3
            done

            # Read token and CA cert
            TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
            CA_CERT=$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)
            API_SERVER=https://kubernetes.default.svc.cluster.local:443

            # Create index.html
            cat > /usr/share/nginx/html/index.html <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Talos Rescue Login</title>
    <style>
        body { font-family: 'Courier New', monospace; padding: 40px; background: #000; color: #0f0; }
        .token { background: #000; color: #0f0; padding: 1rem; border-radius: 5px; margin: 20px 0; white-space: pre-wrap; font-size: 14px; }
        button { padding: 10px 20px; cursor: pointer; margin-top: 20px; background: #0f0; color: #000; border: none; }
        h1, p { color: #0f0; }
    </style>
</head>
<body>
    <h1>üîë CLUSTER RESCUE TOKEN</h1>
    <p><strong>Copy this token to bypass expired certificates:</strong></p>
    <div class="token">$TOKEN</div>
    <button onclick="navigator.clipboard.writeText(document.querySelector('.token').textContent)">üìã COPY TO CLIPBOARD</button>

    <hr>

    <p><strong>Use in kubectl (from your laptop):</strong></p>
    <pre>kubectl --token="$TOKEN" --server="$API_SERVER" --certificate-authority=data:application/x-pem-file;base64,$(base64 -w 0 &lt;&lt;&lt; "$CA_CERT") --insecure-skip-tls-verify=false get nodes</pre>

    <p><em>Note: If your API server cert is expired, you may still need to add --insecure-skip-tls-verify</em></p>
    <p><em>üëâ Once you regain access, rotate certs with: <code>talosctl rotate certs</code></em></p>
    <p><em>This page will vanish after you delete this Resource. Do not leave it running.</em></p>
</body>
</html>
EOF

            # Start Nginx
            exec nginx -g 'daemon off;'
        resources:
          limits:
            memory: "64Mi"
            cpu: "50m"
        securityContext:
          readOnlyRootFilesystem: true
      volumes:
      - name: html-volume
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: rescue-web
  labels:
    app: rescue-web
spec:
  selector:
    app: rescue-web
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rescue-web
  annotations:
    kubernetes.io/ingress.class: "nginx"             # ‚Üê CHANGE IF USING TRAEFIK/HAPROXY
    cert-manager.io/cluster-issuer: "letsencrypt-prod" # ‚Üê CHANGE TO YOUR ISSUER
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - local.rescue
    secretName: rescue-tls-secret  # Will be auto-created by cert-manager
  rules:
  - host: local.rescue
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rescue-web
            port:
              number: 80
